# --- sing-box nft bypass by MAC (4 chains) ---
(
  # nftables: family + table
  FAMILY="inet"
  TABLE="sing-box"

  # 需要处理的链：4 条
  CHAINS="prerouting prerouting_udp_icmp output output_udp_icmp"

  # 要绕过的主机 MAC 地址（每行一个或空格分隔，大小写均可）
  MACS="
    BC:24:11:BD:DD:43
    aa:bb:cc:dd:ee:ff
  "

  # 等待表 / 链出现的最大时间（秒）
  MAX_TABLE_WAIT=120
  MAX_CHAIN_WAIT=10

  norm_mac() {
    # 规范化为小写、去空白
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | tr -d ' \t\r\n'
  }

  # 等待 inet sing-box 表出现
  i=0
  while [ $i -lt $MAX_TABLE_WAIT ]; do
    if nft list table "$FAMILY" "$TABLE" >/dev/null 2>&1; then
      break
    fi
    sleep 1
    i=$((i+1))
  done

  # 表还没出现就退出（不报错，避免卡启动）
  nft list table "$FAMILY" "$TABLE" >/dev/null 2>&1 || exit 0

  # 针对每条链插入规则
  for chain in $CHAINS; do
    # 等链出现（短等）
    j=0
    while [ $j -lt $MAX_CHAIN_WAIT ]; do
      if nft list chain "$FAMILY" "$TABLE" "$chain" >/dev/null 2>&1; then
        break
      fi
      sleep 1
      j=$((j+1))
    done

    # 链不存在就跳过（可能当前配置没启用对应链）
    if ! nft list chain "$FAMILY" "$TABLE" "$chain" >/dev/null 2>&1; then
      continue
    fi

    # 对每个 MAC 做幂等插入
    for mac in $MACS; do
      norm="$(norm_mac "$mac")"
      [ -z "$norm" ] && continue

      # 已存在同 MAC 的 return 则跳过
      if nft list chain "$FAMILY" "$TABLE" "$chain" 2>/dev/null | grep -qi "ether saddr *$norm .*return"; then
        continue
      fi

      # 插入链头（带 counter 方便观察）
      nft insert rule "$FAMILY" "$TABLE" "$chain" ether saddr "$norm" counter return
    done
  done
) &
# --- end sing-box nft bypass by MAC ---

exit 0